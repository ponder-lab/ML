<?xml version="1.0" ?>
<!DOCTYPE summary-spec>
<!-- TensorFlow model -->
<summary-spec>
  <classloader name="PythonLoader">
    <class name="tensorflow" allocatable="true">
      <method name="import" static="true" descriptor="()Ltensorflow;">
        <new def="x" class="Ltensorflow" />
        <new def="train" class="Lobject" />
        <putfield class="LRoot" field="train" fieldType="LRoot" ref="x" value="train" />
        <new def="nn" class="Lobject" />
        <putfield class="LRoot" field="nn" fieldType="LRoot" ref="x" value="nn" />
        <new def="layers" class="Lobject" />
        <putfield class="LRoot" field="layers" fieldType="LRoot" ref="x" value="layers" />
        <new def="losses" class="Lobject" />
        <putfield class="LRoot" field="losses" fieldType="LRoot" ref="x" value="losses" />
        <new def="random" class="Lobject" />
        <putfield class="LRoot" field="random" fieldType="LRoot" ref="x" value="random" />
        <new def="math" class="Lobject" />
        <putfield class="LRoot" field="math" fieldType="LRoot" ref="x" value="math" />
        <new def="sparse" class="Lobject" />
        <putfield class="LRoot" field="sparse" fieldType="LRoot" ref="x" value="sparse" />
        <new def="linalg" class="Lobject" />
        <putfield class="LRoot" field="linalg" fieldType="LRoot" ref="x" value="linalg" />
        <new def="keras" class="Lobject" />
        <putfield class="LRoot" field="keras" fieldType="LRoot" ref="x" value="keras" />
        <putfield class="LRoot" field="layers" fieldType="LRoot" ref="keras" value="layers" />
        <new def="models" class="Lobject" />
        <putfield class="LRoot" field="models" fieldType="LRoot" ref="keras" value="models" />
        <new def="preprocessing" class="Lobject" />
        <putfield class="LRoot" field="preprocessing" fieldType="LRoot" ref="keras" value="preprocessing" />
        <new def="image" class="Lobject" />
        <putfield class="LRoot" field="image" fieldType="LRoot" ref="preprocessing" value="image" />
        <new def="app" class="Lobject" />
        <putfield class="LRoot" field="app" fieldType="LRoot" ref="x" value="app" />
        <new def="run" class="Ltensorflow/app/run" />
        <putfield class="LRoot" field="run" fieldType="LRoot" ref="app" value="run" />
        <new def="estimator" class="Lobject" />
        <putfield class="LRoot" field="estimator" fieldType="LRoot" ref="x" value="estimator" />
        <new def="inputs" class="Lobject" />
        <putfield class="LRoot" field="inputs" fieldType="LRoot" ref="estimator" value="inputs" />
        <new def="numpy_input_fn" class="Ltensorflow/estimator/numpy_input_fn" />
        <putfield class="LRoot" field="numpy_input_fn" fieldType="LRoot" ref="inputs" value="numpy_input_fn" />
        <new def="Estimator" class="Ltensorflow/estimator/Estimator" />
        <putfield class="LRoot" field="Estimator" fieldType="LRoot" ref="estimator" value="Estimator" />
        <new def="data" class="Lobject" />
        <putfield class="LRoot" field="data" fieldType="LRoot" ref="x" value="data" />
        <new def="Dataset" class="Ltensorflow/data/Dataset" />
        <putfield class="LRoot" field="Dataset" fieldType="LRoot" ref="data" value="Dataset" />
        <new def="distribute" class="Lobject" />
        <putfield class="LRoot" field="distribute" fieldType="LRoot" ref="x" value="distribute" />
        <new def="MirroredStrategy" class="Ltensorflow/distribute/MirroredStrategy" />
        <putfield class="LRoot" field="MirroredStrategy" fieldType="LRoot" ref="distribute" value="MirroredStrategy" />
        <new def="function" class="Ltensorflow/class/function" />
        <putfield class="LRoot" field="function" fieldType="LRoot" ref="x" value="function" />
        <new def="AdamOptimizer" class="Ltensorflow/functions/AdamOptimizer" />
        <putfield class="LRoot" field="AdamOptimizer" fieldType="LRoot" ref="train" value="AdamOptimizer" />
        <new def="shuffle_batch" class="Ltensorflow/functions/shuffle_batch" />
        <putfield class="LRoot" field="shuffle_batch" fieldType="LRoot" ref="train" value="shuffle_batch" />
        <new def="InteractiveSession" class="Ltensorflow/functions/InteractiveSession" />
        <putfield class="LRoot" field="InteractiveSession" fieldType="LRoot" ref="x" value="InteractiveSession" />
        <putfield class="LRoot" field="Session" fieldType="LRoot" ref="x" value="InteractiveSession" />
        <new def="parse_single_example" class="Ltensorflow/functions/parse_single_example" />
        <putfield class="LRoot" field="parse_single_example" fieldType="LRoot" ref="x" value="parse_single_example" />
        <new def="FixedLenFeature" class="Ltensorflow/functions/FixedLenFeature" />
        <putfield class="LRoot" field="FixedLenFeature" fieldType="LRoot" ref="x" value="FixedLenFeature" />
        <new def="pass_through" class="Ltensorflow/functions/pass_through" />
        <new def="cast" class="Ltensorflow/functions/cast" />
        <putfield class="LRoot" field="cast" fieldType="LRoot" ref="x" value="cast" />
        <putfield class="LRoot" field="decode_raw" fieldType="LRoot" ref="x" value="pass_through" />
        <new def="log" class="Ltensorflow/math/log" />
        <putfield class="LRoot" field="log" fieldType="LRoot" ref="x" value="log" />
        <putfield class="LRoot" field="log" fieldType="LRoot" ref="math" value="log" />
        <new def="reduce_sum" class="Ltensorflow/math/reduce_sum" />
        <putfield class="LRoot" field="reduce_sum" fieldType="LRoot" ref="x" value="reduce_sum" />
        <putfield class="LRoot" field="reduce_sum" fieldType="LRoot" ref="math" value="reduce_sum" />
        <new def="argmax" class="Ltensorflow/math/argmax" />
        <putfield class="LRoot" field="argmax" fieldType="LRoot" ref="x" value="argmax" />
        <putfield class="LRoot" field="argmax" fieldType="LRoot" ref="math" value="argmax" />
        <new def="equal" class="Ltensorflow/math/equal" />
        <putfield class="LRoot" field="equal" fieldType="LRoot" ref="x" value="equal" />
        <putfield class="LRoot" field="equal" fieldType="LRoot" ref="math" value="equal" />
        <new def="matmul" class="Ltensorflow/functions/matmul" />
        <putfield class="LRoot" field="matmul" fieldType="LRoot" ref="x" value="matmul" />
        <new def="dense" class="Ltensorflow/functions/dense" />
        <putfield class="LRoot" field="dense" fieldType="LRoot" ref="layers" value="dense" />
        <new def="flatten" class="Ltensorflow/functions/flatten" />
        <putfield class="LRoot" field="flatten" fieldType="LRoot" ref="layers" value="flatten" />
        <new def="dropout_val" class="Ltensorflow/functions/pass_through" />
        <putfield class="LRoot" field="dropout" fieldType="LRoot" ref="layers" value="dropout_val" />
        <putfield class="LRoot" field="dropout" fieldType="LRoot" ref="nn" value="dropout_val" />
        <new def="conv2d" class="Ltensorflow/functions/conv2d" />
        <putfield class="LRoot" field="conv2d" fieldType="LRoot" ref="x" value="conv2d" />
        <putfield class="LRoot" field="conv2d" fieldType="LRoot" ref="nn" value="conv2d" />
        <putfield class="LRoot" field="conv2d" fieldType="LRoot" ref="layers" value="conv2d" />
        <new def="max_pool" class="Ltensorflow/functions/max_pool" />
        <putfield class="LRoot" field="max_pool" fieldType="LRoot" ref="nn" value="max_pool" />
        <putfield class="LRoot" field="max_pooling2d" fieldType="LRoot" ref="nn" value="max_pool" />
        <putfield class="LRoot" field="max_pooling2d" fieldType="LRoot" ref="layers" value="max_pool" />
        <putfield class="LRoot" field="relu" fieldType="LRoot" ref="nn" value="pass_through" />
        <new def="sigmoid" class="Ltensorflow/math/sigmoid" />
        <putfield class="LRoot" field="sigmoid" fieldType="LRoot" ref="nn" value="sigmoid" />
        <putfield class="LRoot" field="sigmoid" fieldType="LRoot" ref="math" value="sigmoid" />
        <new def="softmax" class="Ltensorflow/functions/softmax" />
        <putfield class="LRoot" field="softmax" fieldType="LRoot" ref="nn" value="softmax" />
        <new def="softmax_cross_entropy_with_logits" class="Ltensorflow/functions/softmax_cross_entropy_with_logits" />
        <putfield class="LRoot" field="softmax_cross_entropy_with_logits" fieldType="LRoot" ref="nn" value="softmax_cross_entropy_with_logits" />
        <putfield class="LRoot" field="softmax_cross_entropy_with_logits_v2" fieldType="LRoot" ref="nn" value="softmax_cross_entropy_with_logits" />
        <new def="sparse_softmax_cross_entropy_with_logits_val" class="Ltensorflow/functions/sparse_softmax_cross_entropy_with_logits" />
        <putfield class="LRoot" field="sparse_softmax_cross_entropy_with_logits" fieldType="LRoot" ref="nn" value="sparse_softmax_cross_entropy_with_logits_val" />
        <putfield class="LRoot" field="sparse_softmax_cross_entropy" fieldType="LRoot" ref="losses" value="sparse_softmax_cross_entropy_with_logits_val" />
        <new def="uniform" class="Ltensorflow/functions/uniform" />
        <putfield class="LRoot" field="uniform" fieldType="LRoot" ref="random" value="uniform" />
        <new def="gamma" class="Ltensorflow/functions/gamma" />
        <putfield class="LRoot" field="gamma" fieldType="LRoot" ref="random" value="gamma" />
        <new def="normal" class="Ltensorflow/functions/normal" />
        <putfield class="LRoot" field="normal" fieldType="LRoot" ref="random" value="normal" />
        <new def="poisson" class="Ltensorflow/functions/poisson" />
        <putfield class="LRoot" field="poisson" fieldType="LRoot" ref="random" value="poisson" />
        <new def="truncated_normal" class="Ltensorflow/functions/truncated_normal" />
        <putfield class="LRoot" field="truncated_normal" fieldType="LRoot" ref="random" value="truncated_normal" />
        <putfield class="LRoot" field="identity" fieldType="LRoot" ref="x" value="pass_through" />
        <new def="Graph_val" class="Ltensorflow/Graph" />
        <putfield class="LRoot" field="Graph" fieldType="LRoot" ref="x" value="Graph_val" />
        <new def="get_default_graph" class="Ltensorflow/functions/get_default_graph" />
        <putfield class="LRoot" field="get_default_graph" fieldType="LRoot" ref="x" value="get_default_graph" />
        <new def="Session_val" class="Ltensorflow/Session" />
        <putfield class="LRoot" field="Session" fieldType="LRoot" ref="x" value="Session_val" />
        <new def="GradientDescentOptimizer" class="Ltensorflow/functions/GradientDescentOptimizer" />
        <putfield class="LRoot" field="GradientDescentOptimizer" fieldType="LRoot" ref="train" value="GradientDescentOptimizer" />
        <new def="placeholder" class="Ltensorflow/functions/placeholder" />
        <putfield class="LRoot" field="placeholder" fieldType="LRoot" ref="x" value="placeholder" />
        <new def="examples" class="Lobject" />
        <putfield class="LRoot" field="examples" fieldType="LRoot" ref="x" value="examples" />
        <new def="tutorials" class="Lobject" />
        <putfield class="LRoot" field="tutorials" fieldType="LRoot" ref="examples" value="tutorials" />
        <new def="mnist_mod" class="Ltensorflow/examples/tutorials/mnist" />
        <putfield class="LRoot" field="mnist" fieldType="LRoot" ref="tutorials" value="mnist_mod" />
        <new def="id" class="Lobject" />
        <putfield class="LRoot" field="input_data" fieldType="LRoot" ref="mnist_mod" value="id" />
        <new def="rds" class="Ltensorflow/examples/tutorials/mnist/read_data_sets" />
        <putfield class="LRoot" field="read_data_sets" fieldType="LRoot" ref="id" value="rds" />
        <new def="python" class="Lobject" />
        <putfield class="LRoot" field="python" fieldType="LRoot" ref="x" value="python" />
        <new def="framework" class="Lobject" />
        <putfield class="LRoot" field="framework" fieldType="LRoot" ref="python" value="framework" />
        <new def="ops" class="Lobject" />
        <putfield class="LRoot" field="ops" fieldType="LRoot" ref="python" value="ops" />
        <putfield class="LRoot" field="ops" fieldType="LRoot" ref="framework" value="ops" />
        <new def="ragged" class="Lobject" />
        <putfield class="LRoot" field="ragged" fieldType="LRoot" ref="x" value="ragged" />
        <putfield class="LRoot" field="ragged" fieldType="LRoot" ref="ops" value="ragged" />
        <new def="experimental" class="Lobject" />
        <putfield class="LRoot" field="experimental" fieldType="LRoot" ref="x" value="experimental" />
        <new def="numpy" class="Lobject" />
        <putfield class="LRoot" field="numpy" fieldType="LRoot" ref="experimental" value="numpy" />
        <new def="array_ops" class="Lobject" />
        <putfield class="LRoot" field="array_ops" fieldType="LRoot" ref="ops" value="array_ops" />
        <new def="random_ops" class="Lobject" />
        <putfield class="LRoot" field="random_ops" fieldType="LRoot" ref="ops" value="random_ops" />
        <new def="math_ops" class="Lobject" />
        <putfield class="LRoot" field="math_ops" fieldType="LRoot" ref="ops" value="math_ops" />
        <new def="linalg_ops" class="Lobject" />
        <putfield class="LRoot" field="linalg_ops" fieldType="LRoot" ref="ops" value="linalg_ops" />
        <new def="sparse_ops" class="Lobject" />
        <putfield class="LRoot" field="sparse_ops" fieldType="LRoot" ref="ops" value="sparse_ops" />
        <new def="variables" class="Lobject" />
        <putfield class="LRoot" field="variables" fieldType="LRoot" ref="ops" value="variables" />
        <new def="sparse_tensor" class="Lobject" />
        <putfield class="LRoot" field="sparse_tensor" fieldType="LRoot" ref="framework" value="sparse_tensor" />
        <new def="constant_op" class="Lobject" />
        <putfield class="LRoot" field="constant_op" fieldType="LRoot" ref="framework" value="constant_op" />
        <putfield class="LRoot" field="random_uniform" fieldType="LRoot" ref="random_ops" value="uniform" />
        <putfield class="LRoot" field="random_gamma" fieldType="LRoot" ref="random_ops" value="gamma" />
        <putfield class="LRoot" field="random_normal" fieldType="LRoot" ref="random_ops" value="normal" />
        <putfield class="LRoot" field="random_poisson_v2" fieldType="LRoot" ref="random_ops" value="poisson" />
        <putfield class="LRoot" field="truncated_normal" fieldType="LRoot" ref="random_ops" value="truncated_normal" />
        <new def="zeros" class="Ltensorflow/functions/zeros" />
        <putfield class="LRoot" field="zeros" fieldType="LRoot" ref="x" value="zeros" />
        <putfield class="LRoot" field="zeros" fieldType="LRoot" ref="array_ops" value="zeros" />
        <new def="zeros_like" class="Ltensorflow/functions/zeros_like" />
        <putfield class="LRoot" field="zeros_like" fieldType="LRoot" ref="x" value="zeros_like" />
        <putfield class="LRoot" field="zeros_like" fieldType="LRoot" ref="array_ops" value="zeros_like" />
        <new def="ones" class="Ltensorflow/functions/ones" />
        <putfield class="LRoot" field="ones" fieldType="LRoot" ref="x" value="ones" />
        <putfield class="LRoot" field="ones" fieldType="LRoot" ref="array_ops" value="ones" />
        <new def="constant" class="Ltensorflow/functions/constant" />
        <putfield class="LRoot" field="constant" fieldType="LRoot" ref="x" value="constant" />
        <putfield class="LRoot" field="constant" fieldType="LRoot" ref="constant_op" value="constant" />
        <new def="reshape" class="Ltensorflow/functions/reshape" />
        <putfield class="LRoot" field="reshape" fieldType="LRoot" ref="x" value="reshape" />
        <putfield class="LRoot" field="reshape" fieldType="LRoot" ref="array_ops" value="reshape" />
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/dtypes -->
        <new def="dtypes" class="Lobject" />
        <putfield class="LRoot" field="dtypes" fieldType="LRoot" ref="framework" value="dtypes" />
        <new def="ragged_factory_ops" class="Lobject" />
        <putfield class="LRoot" field="ragged_factory_ops" fieldType="LRoot" ref="ragged" value="ragged_factory_ops" />
        <new def="ragged_math_ops" class="Lobject" />
        <putfield class="LRoot" field="ragged_math_ops" fieldType="LRoot" ref="ragged" value="ragged_math_ops" />
        <new def="ragged_tensor" class="Lobject" />
        <putfield class="LRoot" field="ragged_tensor" fieldType="LRoot" ref="ragged" value="ragged_tensor" />
        <new def="ndarray" class="Ltensorflow/functions/ndarray" />
        <putfield class="LRoot" field="ndarray" fieldType="LRoot" ref="numpy" value="ndarray" />
        <new def="Input" class="Ltensorflow/keras/layers/Input" />
        <putfield class="LRoot" field="Input" fieldType="LRoot" ref="layers" value="Input" />
        <return value="x" />
      </method>
    </class>
    <class name="keras" allocatable="true">
      <method name="import" static="true" descriptor="()Lkeras;">
        <new def="x" class="Lkeras" />
        <new def="engine" class="Lobject" />
        <putfield class="LRoot" field="engine" fieldType="LRoot" ref="x" value="engine" />
        <new def="input_layer" class="Lobject" />
        <putfield class="LRoot" field="input_layer" fieldType="LRoot" ref="engine" value="input_layer" />
        <new def="Input" class="Ltensorflow/keras/layers/Input" />
        <putfield class="LRoot" field="Input" fieldType="LRoot" ref="input_layer" value="Input" />
        <return value="x" />
      </method>
    </class>
    <package name="tensorflow/class">
      <class name="Function" allocatable="true">
        <method name="do" descriptor="()LRoot;" numArgs="2" paramNames="self test">
          <putfield class="LRoot" field="params" fieldType="LRoot" ref="test" value="self" />
          <return value="test" />
        </method>
      </class>
      <class name="function" allocatable="true">
        <!-- These parameters are from TensorFlow v.2.9 https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/function -->
        <method name="do" descriptor="()LRoot;" numArgs="11" paramNames="self func input_signature autograph jit_compile reduce_retracing experimental_implements experimental_autograph_options experimental_relax_shapes experimental_compile experimental_follow_type_hints">
          <new def="params" class="Ltensorflow/class/Function" />
          <putfield class="LRoot" field="func" fieldType="LRoot" ref="params" value="func" />
          <putfield class="LRoot" field="input_signature" fieldType="LRoot" ref="params" value="input_signature" />
          <putfield class="LRoot" field="autograph" fieldType="LRoot" ref="params" value="autograph" />
          <putfield class="LRoot" field="jit_compile" fieldType="LRoot" ref="params" value="jit_compile" />
          <putfield class="LRoot" field="reduce_retracing" fieldType="LRoot" ref="params" value="reduce_retracing" />
          <putfield class="LRoot" field="experimental_implements" fieldType="LRoot" ref="params" value="experimental_implements" />
          <putfield class="LRoot" field="experimental_autograph_options" fieldType="LRoot" ref="params" value="experimental_autograph_options" />
          <putfield class="LRoot" field="experimental_relax_shapes" fieldType="LRoot" ref="params" value="experimental_relax_shapes" />
          <putfield class="LRoot" field="experimental_compile" fieldType="LRoot" ref="params" value="experimental_compile" />
          <putfield class="LRoot" field="experimental_follow_type_hints" fieldType="LRoot" ref="params" value="experimental_follow_type_hints" />
          <return value="params" />
        </method>
      </class>
      <class name="Do_not_convert" allocatable="true">
        <method name="do" descriptor="()LRoot;" numArgs="2" paramNames="self test">
          <putfield class="LRoot" field="params" fieldType="LRoot" ref="test" value="self" />
          <return value="test" />
        </method>
      </class>
      <class name="do_not_convert" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/autograph/experimental/do_not_convert -->
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="self params values extra">
          <new def="closure" class="Ltensorflow/class/Do_not_convert" />
          <putfield class="LRoot" field="test" fieldType="LRoot" ref="closure" value="self" />
          <putfield class="LRoot" field="params" fieldType="LRoot" ref="closure" value="params" />
          <putfield class="LRoot" field="values" fieldType="LRoot" ref="closure" value="values" />
          <return value="closure" />
        </method>
      </class>
    </package>
    <package name="tensorflow/dtypes">
      <class name="DType" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/dtypes/DType -->
        <method name="do" descriptor="()LRoot;" numArgs="3" paramNames="self type_enum handle_data">
          <new def="obj" class="Ltensorflow/DType" />
          <putfield class="LRoot" field="type_enum" fieldType="LRoot" ref="obj" value="type_enum" />
          <putfield class="LRoot" field="handle_data" fieldType="LRoot" ref="obj" value="handle_data" />
          <return value="obj" />
        </method>
      </class>
    </package>
    <package name="tensorflow/objects">
      <class name="feature" allocatable="true" />
    </package>
    <package name="keras/objects">
      <class name="feature" allocatable="true" />
    </package>
    <package name="tensorflow/python/framework/sparse_tensor">
      <class name="SparseTensor" allocatable="true">
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="self indices values dense_shape">
          <return value="self" />
        </method>
      </class>
      <class name="sparse_eye" allocatable="true">
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="self num_rows num_columns dtype name">
          <return value="self" />
        </method>
      </class>
    </package>
    <package name="tensorflow/math">
      <class name="log" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/python/framework/ops/Tensor" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="3" paramNames="self x name">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="xx" />
          <return value="xx" />
        </method>
      </class>
      <class name="sigmoid" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/nn/sigmoid -->
        <method name="do" descriptor="()LRoot;" numArgs="3" paramNames="self x name">
          <return value="x" />
        </method>
      </class>
      <class name="add" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/add -->
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/math/add" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="self x y name">
          <!-- Even though tf.add() isn't a tensor "generator," it can convert its non-tensor arguments to tensors. -->
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="xx" />
          <return value="xx" />
        </method>
      </class>
      <class name="multiply" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/multiply -->
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/math/multiply" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="self x y name">
          <!-- Even though tf.multiply() isn't a tensor "generator," it can convert its non-tensor arguments to tensors. -->
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="xx" />
          <return value="xx" />
        </method>
      </class>
      <class name="reduce_mean" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/reduce_mean -->
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/python/framework/ops/Tensor" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="5" paramNames="self input_tensor axis keepdims name">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="y" />
          <return value="y" />
        </method>
      </class>
      <class name="reduce_sum" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/python/framework/ops/Tensor" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="5" paramNames="self input_tensor axis keepdims name">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="xx" />
          <return value="xx" />
        </method>
      </class>
      <class name="argmax" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/python/framework/ops/Tensor" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="5" paramNames="self input axis name dimension">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="xx" />
          <return value="xx" />
        </method>
      </class>
      <class name="equal" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/python/framework/ops/Tensor" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="self x y name">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="xx" />
          <return value="xx" />
        </method>
      </class>
    </package>
    <package name="tensorflow/python/framework/ops">
      <class name="Tensor" allocatable="true" />
      <class name="convert_to_tensor" allocatable="true" />
      <class name="ndarray" allocatable="true" />
    </package>
    <package name="tensorflow/functions">
      <class name="AdamOptimizer" allocatable="true">
        <method name="do" descriptor="()LRoot;">
          <new def="opt" class="Lobject" />
          <new def="minimize" class="Ltensorflow/functions/minimize" />
          <putfield class="LRoot" field="minimize" fieldType="LRoot" ref="opt" value="minimize" />
          <return value="opt" />
        </method>
      </class>
      <class name="minimize" allocatable="true">
        <method name="do" descriptor="()LRoot;">
          <new def="v" class="Lobject" />
          <new def="f" class="Ltensorflow/functions/Runner" />
          <putfield class="LRoot" field="run" fieldType="LRoot" ref="v" value="f" />
          <return value="v" />
        </method>
      </class>
      <class name="shuffle_batch" allocatable="true">
        <method name="do" descriptor="()LRoot;" numArgs="3" paramNames="self data">
          <return value="data" />
        </method>
      </class>
      <class name="InteractiveSession" allocatable="true">
        <method name="do" descriptor="()LRoot;">
          <new def="v" class="Lobject" />
          <new def="f" class="Ltensorflow/functions/Runner" />
          <putfield class="LRoot" field="run" fieldType="LRoot" ref="v" value="f" />
          <return value="v" />
        </method>
      </class>
      <class name="Runner" allocatable="true">
        <method name="do" descriptor="()LRoot;" numArgs="3" paramNames="self graph feed_dict">
          <return value="self" />
        </method>
      </class>
      <class name="set_shape" allocatable="true">
        <method name="do" descriptor="()LRoot;" numArgs="2" paramNames="self shape">
          <return value="self" />
        </method>
      </class>
      <class name="reshape" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/reshape -->
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/python/framework/ops/Tensor" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="self tensor shape name">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="self" numArgs="1" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="ones" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/python/framework/ops/Tensor" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="self shape dtype name">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="self" numArgs="1" def="x" />
          <putfield class="Ltensorflow/python/framework/ops/Tensor" field="dtype" fieldType="LRoot" ref="x" value="dtype" />
          <putfield class="Ltensorflow/python/framework/ops/Tensor" field="shape" fieldType="LRoot" ref="x" value="shape" />
          <return value="x" />
        </method>
      </class>
      <class name="Variable" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/python/ops/variables/Variable" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="13" paramNames="self initial_value trainable validate_shape caching_device name variable_def dtype import_scope constraint synchronization aggregation shape">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="x" />
          <putfield class="Ltensorflow/python/ops/variables/Variable" field="initial_value" fieldType="LRoot" ref="x" value="initial_value" />
          <putfield class="Ltensorflow/python/ops/variables/Variable" field="shape" fieldType="LRoot" ref="x" value="shape" />
          <putfield class="Ltensorflow/python/ops/variables/Variable" field="dtype" fieldType="LRoot" ref="x" value="dtype" />
          <return value="x" />
        </method>
      </class>
      <class name="constant" allocatable="true">
        <method name="do" descriptor="()LRoot;" numArgs="5" paramNames="self value dtype shape name">
          <new def="x" class="Ltensorflow/python/framework/constant_op/constant" />
          <putfield class="Ltensorflow/python/framework/constant_op/constant" field="value" fieldType="LRoot" ref="x" value="value" />
          <return value="x" />
        </method>
      </class>
      <class name="zeros" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/python/ops/array_ops/zeros" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="self shape dtype name">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="x" />
          <putfield class="Ltensorflow/python/ops/array_ops/zeros" field="dtype" fieldType="LRoot" ref="x" value="dtype" />
          <putfield class="Ltensorflow/python/ops/array_ops/zeros" field="shape" fieldType="LRoot" ref="x" value="shape" />
          <return value="x" />
        </method>
      </class>
      <class name="SparseTensor" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/python/framework/sparse_tensor/SparseTensor" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="self indices values dense_shape">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="x" />
          <putfield class="LRoot" field="indices" fieldType="LRoot" ref="x" value="indices" />
          <putfield class="LRoot" field="values" fieldType="LRoot" ref="x" value="values" />
          <putfield class="LRoot" field="dense_shape" fieldType="LRoot" ref="x" value="dense_shape" />
          <return value="x" />
        </method>
      </class>
      <class name="sparse_eye" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/python/framework/sparse_tensor/SparseTensor" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="5" paramNames="self num_rows num_columns dtype name">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="x" />
          <new def="shape" class="Llist" />
          <putfield class="LRoot" field="0" fieldType="LRoot" ref="shape" value="num_rows" />
          <putfield class="LRoot" field="1" fieldType="LRoot" ref="shape" value="num_columns" />
          <putfield class="LRoot" field="dense_shape" fieldType="LRoot" ref="x" value="shape" />
          <new def="val_list" class="Llist" />
          <constant name="one" type="float" value="1.0" />
          <putfield class="LRoot" field="0" fieldType="LRoot" ref="val_list" value="one" />
          <putfield class="LRoot" field="values" fieldType="LRoot" ref="x" value="val_list" />
          <return value="x" />
        </method>
      </class>
      <class name="sparse_add" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/python/framework/sparse_tensor/SparseTensor" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="5" paramNames="self a b threshold name">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="fill" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/python/ops/array_ops/fill" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="3" paramNames="dims value name">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="zeros_like" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/python/ops/array_ops/zeros_like" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="self input dtype name">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="x" />
          <putfield class="Ltensorflow/python/ops/array_ops/zeros_like" field="input" fieldType="LRoot" ref="x" value="input" />
          <putfield class="Ltensorflow/python/ops/array_ops/zeros_like" field="dtype" fieldType="LRoot" ref="x" value="dtype" />
          <return value="x" />
        </method>
      </class>
      <class name="one_hot" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/python/ops/array_ops/one_hot" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="8" paramNames="self indices depth on_value off_value axis dtype name">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="convert_to_tensor" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/python/framework/ops/convert_to_tensor" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="value dtype dtype_hint name">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="range" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Llist" />
          <new def="z" class="Ltensorflow/functions/constant" />
          <constant name="p" type="int" value="1" /> <!-- FIXME: The type may actually depend on the arguments passed to `tf.range()`. It may not necessarily be `int`. -->
          <call class="Ltensorflow/functions/constant" name="do" descriptor="()LRoot;" type="virtual" arg0="z" arg1="p" numArgs="2" def="y" />
          <putfield class="LRoot" field="0" fieldType="LRoot" ref="x" value="y" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="5" paramNames="start limit delta dtype name">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="Tensor" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/python/framework/ops/Tensor" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="self op value_index dtype">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="self" numArgs="1" def="x" />
          <putfield class="Ltensorflow/python/framework/ops/Tensor" field="dtype" fieldType="LRoot" ref="x" value="dtype" />
          <return value="x" />
        </method>
        <method name="eval" descriptor="()LRoot;" numArgs="3" paramNames="self feed_dict session">
          <return value="self" />
        </method>
        <method name="set_shape" descriptor="()LRoot;" numArgs="2" paramNames="self shape">
          <return value="self" />
        </method>
      </class>
      <class name="ndarray" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/python/framework/ops/ndarray" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="self op value_index dtype">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="self" numArgs="1" def="x" />
          <putfield class="Ltensorflow/python/framework/ops/ndarray" field="dtype" fieldType="LRoot" ref="x" value="dtype" />
          <return value="x" />
        </method>
      </class>
      <class name="ragged_range" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/python/ops/ragged/ragged_math_ops/range" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="6" paramNames="starts limits deltas dtype name row_splits_dtype">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="ragged_constant" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/python/ops/ragged/ragged_factory_ops/constant" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="6" paramNames="pylist dtype ragged_rank inner_shape name row_splits_dtype">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="eye" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/python/ops/linalg_ops/eye" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="5" paramNames="num_rows num_columns batch_shape dtype name">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="uniform" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/python/ops/random_ops/uniform" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="7" paramNames="self shape minval maxval dtype seed name">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="x" />
          <putfield class="Ltensorflow/python/ops/random_ops/uniform" field="shape" fieldType="LRoot" ref="x" value="shape" />
          <putfield class="Ltensorflow/python/ops/random_ops/uniform" field="dtype" fieldType="LRoot" ref="x" value="dtype" />
          <return value="x" />
        </method>
      </class>
      <class name="gamma" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/python/ops/random_ops/gamma" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="7" paramNames="self shape alpha beta dtype seed name">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="x" />
          <putfield class="Ltensorflow/python/ops/random_ops/gamma" field="shape" fieldType="LRoot" ref="x" value="shape" />
          <putfield class="Ltensorflow/python/ops/random_ops/gamma" field="dtype" fieldType="LRoot" ref="x" value="dtype" />
          <return value="x" />
        </method>
      </class>
      <class name="normal" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/python/ops/random_ops/normal" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="7" paramNames="self shape mean stddev dtype seed name">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="x" />
          <putfield class="Ltensorflow/python/ops/random_ops/normal" field="shape" fieldType="LRoot" ref="x" value="shape" />
          <putfield class="Ltensorflow/python/ops/random_ops/normal" field="dtype" fieldType="LRoot" ref="x" value="dtype" />
          <return value="x" />
        </method>
      </class>
      <class name="poisson" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/python/ops/random_ops/poisson" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="6" paramNames="self shape lam dtype seed name">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="x" />
          <putfield class="Ltensorflow/python/ops/random_ops/poisson" field="shape" fieldType="LRoot" ref="x" value="shape" />
          <putfield class="Ltensorflow/python/ops/random_ops/poisson" field="dtype" fieldType="LRoot" ref="x" value="dtype" />
          <return value="x" />
        </method>
      </class>
      <class name="truncated_normal" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/python/ops/random_ops/truncated_normal" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="7" paramNames="self shape mean stddev dtype seed name">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="x" />
          <putfield class="Ltensorflow/python/ops/random_ops/truncated_normal" field="shape" fieldType="LRoot" ref="x" value="shape" />
          <putfield class="Ltensorflow/python/ops/random_ops/truncated_normal" field="dtype" fieldType="LRoot" ref="x" value="dtype" />
          <return value="x" />
        </method>
      </class>
      <class name="from_nested_row_lengths" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/python/ops/ragged/ragged_tensor/from_nested_row_lengths" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="flat_values nested_row_lengths name validate">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="from_nested_row_splits" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/python/ops/ragged/ragged_tensor/from_nested_row_splits" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="flat_values nested_row_splits name validate">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="from_nested_value_rowids" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/python/ops/ragged/ragged_tensor/from_nested_value_rowids" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="5" paramNames="flat_values nested_value_rowids nested_nrows name validate">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="from_row_lengths" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/python/ops/ragged/ragged_tensor/from_row_lengths" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="values row_lengths name validate">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="from_row_limits" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/python/ops/ragged/ragged_tensor/from_row_limits" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="values row_limits name validate">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="from_row_splits" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/python/ops/ragged/ragged_tensor/from_row_splits" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="values row_splits name validate">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="from_row_starts" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/python/ops/ragged/ragged_tensor/from_row_starts" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="values row_starts name validate">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="from_value_rowids" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/python/ops/ragged/ragged_tensor/from_value_rowids" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="6" paramNames="self values value_rowids nrows name validate">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="placeholder" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/python/framework/ops/Tensor" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="self dtype shape name">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="x" />
          <putfield class="Ltensorflow/python/framework/ops/Tensor" field="dtype" fieldType="LRoot" ref="x" value="dtype" />
          <putfield class="Ltensorflow/python/framework/ops/Tensor" field="shape" fieldType="LRoot" ref="x" value="shape" />
          <return value="x" />
        </method>
      </class>
      <class name="pass_through" allocatable="true">
        <method name="do" descriptor="()LRoot;" numArgs="3" paramNames="self data features">
          <return value="data" />
        </method>
      </class>
      <class name="parse_single_example" allocatable="true">
        <method name="do" descriptor="()LRoot;" numArgs="3" paramNames="self data features">
          <return value="features" />
        </method>
      </class>
      <class name="FixedLenFeature" allocatable="true">
        <method name="do" descriptor="()LRoot;" numArgs="3" paramNames="self dims type">
          <new def="x" class="Ltensorflow/objects/feature" />
          <new def="y" class="Ltensorflow/functions/set_shape" />
          <putfield class="LRoot" field="set_shape" fieldType="LRoot" ref="x" value="y" />
          <return value="x" />
        </method>
      </class>
      <class name="conv2d" allocatable="true">
        <method name="do" descriptor="()LRoot;" numArgs="10" paramNames="self inputs filters kernel_size strides padding data_format dilation_rate activation use_bias">
          <return value="inputs" />
        </method>
      </class>
      <class name="conv3d" allocatable="true">
        <method name="do" descriptor="()LRoot;" numArgs="3" paramNames="self x y">
          <return value="x" />
        </method>
      </class>
      <class name="softmax" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/nn/softmax -->
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="self logits axis name">
          <return value="logits" />
        </method>
      </class>
      <class name="sparse_softmax_cross_entropy_with_logits" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/nn/sparse_softmax_cross_entropy_with_logits -->
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/python/framework/ops/Tensor" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="self labels logits name">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="softmax_cross_entropy_with_logits" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/python/framework/ops/Tensor" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="5" paramNames="self labels logits dim name">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="cast" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="y" class="Ltensorflow/python/framework/ops/Tensor" />
          <return value="y" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="self x dtype name">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="y" />
          <return value="y" />
        </method>
      </class>
      <class name="matmul" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/python/framework/ops/Tensor" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="10" paramNames="self a b transpose_a transpose_b adjoint_a adjoint_b a_is_sparse b_is_sparse name">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="dense" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/python/framework/ops/Tensor" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="16" paramNames="self inputs units activation use_bias kernel_initializer bias_initializer kernel_regularizer bias_regularizer activity_regularizer kernel_constraint bias_constraint trainable name reuse">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="flatten" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/python/framework/ops/Tensor" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="2" paramNames="self inputs">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="max_pool" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/python/framework/ops/Tensor" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="7" paramNames="self value ksize strides padding data_format name">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="get_default_graph" allocatable="true">
        <method name="do" descriptor="()LRoot;" numArgs="1" paramNames="self">
          <new def="x" class="Ltensorflow/Graph" />
          <return value="x" />
        </method>
      </class>
      <class name="GradientDescentOptimizer" allocatable="true">
        <method name="do" descriptor="()LRoot;" numArgs="3" paramNames="self learning_rate name">
          <new def="opt" class="Lobject" />
          <new def="minimize" class="Ltensorflow/functions/minimize" />
          <putfield class="LRoot" field="minimize" fieldType="LRoot" ref="opt" value="minimize" />
          <return value="opt" />
        </method>
      </class>
    </package>
    <package name="tensorflow/estimator">
      <class name="Estimator" allocatable="true">
        <method name="do" descriptor="()LRoot;" numArgs="2" paramNames="self model">
          <new def="x" class="Ltensorflow/estimator/train/train" />
          <putfield class="LRoot" field="train" fieldType="LRoot" ref="self" value="x" />
          <putfield class="LRoot" field="evaluate" fieldType="LRoot" ref="self" value="x" />
          <putfield class="LRoot" field="$callback" fieldType="LRoot" ref="x" value="model" />
          <return value="arg0" />
        </method>
      </class>
      <class name="EstimatorSpec" allocatable="true">
        <method name="do" descriptor="()LRoot;" numArgs="7" paramNames="self mode predictions loss train_op eval_metric_ops export_outputs">
          <return value="eval_metric_ops" />
        </method>
      </class>
      <class name="numpy_input_fn" allocatable="true">
        <method name="do" descriptor="()LRoot;" numArgs="5" paramNames="self x y batch_size shuffle">
          <new def="xx" class="Lobject" />
          <putfield class="LRoot" field="data" fieldType="LRoot" ref="xx" value="arg1" />
          <putfield class="LRoot" field="labels" fieldType="LRoot" ref="xx" value="arg2" />
          <return value="xx" />
        </method>
      </class>
    </package>
    <package name="tensorflow/keras/preprocessing/image">
      <class name="ImageDataGenerator" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/keras/preprocessing/image/ImageDataGenerator -->
        <method name="read_dataset" descriptor="()LRoot;">
          <new def="flow_from_directory" class="Ltensorflow/keras/preprocessing/image/flow_from_directory" />
          <putfield class="LRoot" field="flow_from_directory" fieldType="LRoot" ref="arg0" value="flow_from_directory" />
          <return value="arg0" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="24"
          paramNames="self featurewise_center samplewise_center featurewise_std_normalization samplewise_std_normalization zca_whitening zca_epsilon rotation_range width_shift_range height_shift_range brightness_range shear_range zoom_range channel_shift_range fill_mode cval horizontal_flip vertical_flip rescale preprocessing_function data_format validation_split interpolation_order dtype">
          <!-- NOTE: Workaround for https://github.com/wala/ML/issues/127. This ctor doesn't really return a dataset but rather the instance methods do. It shouldn't be a problem since you can't iterate over an `ImageDataGenerator`. -->
          <call class="LRoot" name="read_dataset" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="flow_from_directory" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/keras/preprocessing/image/ImageDataGenerator#flow_from_directory -->
        <method name="do" descriptor="()LRoot;" numArgs="16" paramNames="self directory target_size color_mode classes class_mode batch_size shuffle seed save_to_dir save_prefix save_format follow_links subset interpolation keep_aspect_ratio">
          <new def="x" class="Ltensorflow/data/Dataset" />
          <call class="Ltensorflow/data/Dataset" name="read_dataset" descriptor="()LRoot;" type="virtual" arg0="x" numArgs="1" def="xx" />
          <return value="xx" />
        </method>
      </class>
    </package>
    <package name="tensorflow/keras/models">
      <class name="Model" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/keras/Model/attribute" />
          <return value="x" />
        </method>
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/keras/models/Model -->
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="self inputs outputs name">
          <new def="__call__" class="Ltensorflow/keras/models/__call__" />
          <putfield class="LRoot" field="__call__" fieldType="LRoot" ref="arg0" value="__call__" />
          <new def="call" class="Ltensorflow/keras/models/call" />
          <putfield class="LRoot" field="call" fieldType="LRoot" ref="arg0" value="call" />
          <new def="x" class="Llist" />
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="xx" />
          <putfield class="LRoot" field="0" fieldType="LRoot" ref="x" value="xx" />
          <!-- https://www.tensorflow.org/guide/keras/transfer_learning#freezing_layers_understanding_the_trainable_attribute -->
          <putfield class="LRoot" field="trainable_weights" fieldType="LRoot" ref="arg0" value="x" />
          <putfield class="LRoot" field="weights" fieldType="LRoot" ref="arg0" value="x" />
          <putfield class="LRoot" field="non_trainable_weights" fieldType="LRoot" ref="arg0" value="x" />
          <return value="arg0" />
        </method>
      </class>
      <class name="__call__" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/keras/Model#call -->
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="self inputs training mask">
          <return value="inputs" />
        </method>
      </class>
      <!-- FIXME: Workaround for https://github.com/wala/ML/issues/106. -->
      <class name="call" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/keras/Model#call -->
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="self inputs training mask">
          <return value="inputs" />
        </method>
      </class>
    </package>
    <package name="tensorflow/keras/layers">
      <class name="Input" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/keras/layers/Input" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="8" paramNames="shape batch_size name dtype sparse tensor ragged type_spec">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="Dense" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/keras/layers/Dense -->
        <method name="do" descriptor="()LRoot;" numArgs="11" paramNames="self units activation use_bias kernel_initializer bias_initializer kernel_regularizer bias_regularizer activity_regularizer kernel_constraint bias_constraint">
          <new def="__call__" class="Ltensorflow/keras/layers/__call__" />
          <putfield class="LRoot" field="__call__" fieldType="LRoot" ref="arg0" value="__call__" />
          <new def="call" class="Ltensorflow/keras/layers/call" />
          <putfield class="LRoot" field="call" fieldType="LRoot" ref="arg0" value="call" />
          <return value="arg0" />
        </method>
      </class>
      <!-- FIXME: These methods must be called explicitly. The implicit cases blocked on https://github.com/wala/ML/issues/127. -->
      <class name="__call__" allocatable="true">
        <!-- https://github.com/keras-team/keras/blob/07e13740fd181fc3ddec7d9a594d8a08666645f6/keras/layers/core/dense.py#L166-L240 -->
        <method name="do" descriptor="()LRoot;" numArgs="2" paramNames="self inputs">
          <return value="inputs" />
        </method>
      </class>
      <!-- FIXME: Workaround for https://github.com/wala/ML/issues/106. -->
      <class name="call" allocatable="true">
        <!-- https://github.com/keras-team/keras/blob/07e13740fd181fc3ddec7d9a594d8a08666645f6/keras/layers/core/dense.py#L166-L240 -->
        <method name="do" descriptor="()LRoot;" numArgs="2" paramNames="self inputs">
          <return value="inputs" />
        </method>
      </class>
    </package>
    <package name="tensorflow">
      <class name="GradientTape" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/GradientTape -->
        <method name="do" descriptor="()LRoot;" numArgs="3" paramNames="self persistent watch_accessed_variables">
          <new def="gradient" class="Ltensorflow/gradient" />
          <putfield class="LRoot" field="gradient" fieldType="LRoot" ref="arg0" value="gradient" />
          <return value="arg0" />
        </method>
      </class>
      <class name="gradient" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/GradientTape#gradient -->
        <method name="do" descriptor="()LRoot;" numArgs="5" paramNames="self target sources output_gradients unconnected_gradients">
          <return value="sources" />
        </method>
      </class>
      <class name="Graph" allocatable="true" />
      <class name="Session" allocatable="true">
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="self target graph config">
          <return value="self" />
        </method>
        <method name="run" descriptor="()LRoot;" numArgs="6" paramNames="self fetches feed_dict options run_metadata">
          <return value="fetches" />
        </method>
        <method name="__enter__" descriptor="()LRoot;" numArgs="1" paramNames="self">
          <return value="self" />
        </method>
        <method name="__exit__" descriptor="()LRoot;" numArgs="4" paramNames="self type value traceback">
          <return value="self" />
        </method>
      </class>
    </package>
    <package name="tensorflow/data">
      <class name="Dataset" allocatable="true">
        <method name="from_tensors" descriptor="()LRoot;" numArgs="1" paramNames="tensors">
          <new def="x" class="Ltensorflow/data/Dataset" />
          <putfield class="Ltensorflow/data/Dataset" field="tensors" fieldType="LRoot" ref="x" value="tensors" />
          <return value="x" />
        </method>
        <method name="from_tensor_slices" descriptor="()LRoot;" numArgs="1" paramNames="tensors">
          <new def="x" class="Ltensorflow/data/Dataset" />
          <putfield class="Ltensorflow/data/Dataset" field="tensors" fieldType="LRoot" ref="x" value="tensors" />
          <return value="x" />
        </method>
        <!-- "read_dataset" means that this function reads a tensor iterable. -->
        <method name="read_dataset" descriptor="()LRoot;">
          <new def="shuffle" class="Ltensorflow/data/shuffle" />
          <putfield class="LRoot" field="shuffle" fieldType="LRoot" ref="arg0" value="shuffle" />
          <new def="batch" class="Ltensorflow/data/batch" />
          <putfield class="LRoot" field="batch" fieldType="LRoot" ref="arg0" value="batch" />
          <new def="repeat" class="Ltensorflow/data/repeat" />
          <putfield class="LRoot" field="repeat" fieldType="LRoot" ref="arg0" value="repeat" />
          <new def="prefetch" class="Ltensorflow/data/prefetch" />
          <putfield class="LRoot" field="prefetch" fieldType="LRoot" ref="arg0" value="prefetch" />
          <new def="with_options" class="Ltensorflow/data/with_options" />
          <putfield class="LRoot" field="with_options" fieldType="LRoot" ref="arg0" value="with_options" />
          <new def="take" class="Ltensorflow/data/take" />
          <putfield class="LRoot" field="take" fieldType="LRoot" ref="arg0" value="take" />
          <return value="arg0" />
          <new def="map" class="Ltensorflow/data/map" />
          <putfield class="LRoot" field="map" fieldType="LRoot" ref="arg0" value="map" />
          <return value="arg0" />
          <new def="filter" class="Ltensorflow/data/filter" />
          <putfield class="LRoot" field="filter" fieldType="LRoot" ref="arg0" value="filter" />
          <new def="concatenate" class="Ltensorflow/data/concatenate" />
          <putfield class="LRoot" field="concatenate" fieldType="LRoot" ref="arg0" value="concatenate" />
          <new def="reduce" class="Ltensorflow/data/reduce" />
          <putfield class="LRoot" field="reduce" fieldType="LRoot" ref="arg0" value="reduce" />
          <new def="enumerate" class="Ltensorflow/data/enumerate" />
          <putfield class="LRoot" field="enumerate" fieldType="LRoot" ref="arg0" value="enumerate" />
          <return value="arg0" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="2" paramNames="self variant_tensor">
          <call class="LRoot" name="read_dataset" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="shuffle" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/data/Dataset#shuffle -->
        <method name="do" descriptor="()LRoot;" numArgs="5" paramNames="self buffer_size seed reshuffle_each_iteration name">
          <!-- FIXME: Workaround for https://github.com/wala/ML/issues/127. This method (shuffle) doesn't really return a "new" dataset but rather a modified version of the receiver. But, the receiver isn't available without a trampoline AFAIK. -->
          <new def="x" class="Ltensorflow/data/Dataset" />
          <call class="Ltensorflow/data/Dataset" name="read_dataset" descriptor="()LRoot;" type="virtual" arg0="x" numArgs="1" def="xx" />
          <putfield class="Ltensorflow/data/Dataset" field="input_dataset" fieldType="LRoot" ref="xx" value="self" />
          <return value="xx" />
        </method>
      </class>
      <class name="batch" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/data/Dataset#batch -->
        <method name="do" descriptor="()LRoot;" numArgs="6" paramNames="self batch_size drop_remainder num_parallel_calls deterministic name">
          <!-- FIXME: Workaround for https://github.com/wala/ML/issues/127. -->
          <new def="x" class="Ltensorflow/data/Dataset" />
          <call class="Ltensorflow/data/Dataset" name="read_dataset" descriptor="()LRoot;" type="virtual" arg0="x" numArgs="1" def="xx" />
          <putfield class="Ltensorflow/data/Dataset" field="input_dataset" fieldType="LRoot" ref="xx" value="self" />
          <putfield class="Ltensorflow/data/Dataset" field="batch_size" fieldType="LRoot" ref="xx" value="batch_size" />
          <return value="xx" />
        </method>
      </class>
      <class name="repeat" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/data/Dataset#repeat -->
        <method name="do" descriptor="()LRoot;" numArgs="6" paramNames="self count name">
          <!-- FIXME: Workaround for https://github.com/wala/ML/issues/127. -->
          <new def="x" class="Ltensorflow/data/Dataset" />
          <call class="Ltensorflow/data/Dataset" name="read_dataset" descriptor="()LRoot;" type="virtual" arg0="x" numArgs="1" def="xx" />
          <return value="xx" />
        </method>
      </class>
      <class name="prefetch" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/data/Dataset#prefetch -->
        <method name="do" descriptor="()LRoot;" numArgs="3" paramNames="self buffer_size name">
          <!-- FIXME: Workaround for https://github.com/wala/ML/issues/127. -->
          <new def="x" class="Ltensorflow/data/Dataset" />
          <call class="Ltensorflow/data/Dataset" name="read_dataset" descriptor="()LRoot;" type="virtual" arg0="x" numArgs="1" def="xx" />
          <return value="xx" />
        </method>
      </class>
      <class name="with_options" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/data/Dataset#with_options -->
        <method name="do" descriptor="()LRoot;" numArgs="3" paramNames="self options name">
          <!-- FIXME: Workaround for https://github.com/wala/ML/issues/127. -->
          <new def="x" class="Ltensorflow/data/Dataset" />
          <call class="Ltensorflow/data/Dataset" name="read_dataset" descriptor="()LRoot;" type="virtual" arg0="x" numArgs="1" def="xx" />
          <return value="xx" />
        </method>
      </class>
      <class name="take" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/data/Dataset#take -->
        <method name="do" descriptor="()LRoot;" numArgs="3" paramNames="self count name">
          <!-- FIXME: Workaround for https://github.com/wala/ML/issues/127. -->
          <new def="x" class="Ltensorflow/data/Dataset" />
          <call class="Ltensorflow/data/Dataset" name="read_dataset" descriptor="()LRoot;" type="virtual" arg0="x" numArgs="1" def="xx" />
          <return value="xx" />
        </method>
      </class>
      <class name="map" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/data/Dataset#map -->
        <method name="do" descriptor="()LRoot;" numArgs="5" paramNames="self map_func num_parallel_calls deterministic name">
          <!-- FIXME: Workaround for https://github.com/wala/ML/issues/127. -->
          <new def="x" class="Ltensorflow/data/Dataset" />
          <call class="Ltensorflow/data/Dataset" name="read_dataset" descriptor="()LRoot;" type="virtual" arg0="x" numArgs="1" def="xx" />
          <putfield class="Ltensorflow/data/Dataset" field="input_dataset" fieldType="LRoot" ref="xx" value="self" />
          <return value="xx" />
        </method>
      </class>
      <class name="filter" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/data/Dataset#filter -->
        <method name="do" descriptor="()LRoot;" numArgs="3" paramNames="self predicate name">
          <!-- FIXME: Workaround for https://github.com/wala/ML/issues/127. -->
          <new def="x" class="Ltensorflow/data/Dataset" />
          <call class="Ltensorflow/data/Dataset" name="read_dataset" descriptor="()LRoot;" type="virtual" arg0="x" numArgs="1" def="xx" />
          <return value="xx" />
        </method>
      </class>
      <class name="concatenate" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/data/Dataset#concatenate -->
        <method name="do" descriptor="()LRoot;" numArgs="3" paramNames="self predicate name">
          <!-- FIXME: Workaround for https://github.com/wala/ML/issues/127. -->
          <new def="x" class="Ltensorflow/data/Dataset" />
          <call class="Ltensorflow/data/Dataset" name="read_dataset" descriptor="()LRoot;" type="virtual" arg0="x" numArgs="1" def="xx" />
          <return value="xx" />
        </method>
      </class>
      <class name="reduce" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/data/Dataset#reduce -->
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="self initial_state reduce_func name">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="xx" />
          <return value="xx" />
        </method>
      </class>
      <class name="enumerate" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/data/Dataset#enumerate -->
        <method name="do" descriptor="()LRoot;" numArgs="3" paramNames="self predicate name">
          <!-- FIXME: Workaround for https://github.com/wala/ML/issues/127. -->
          <new def="x" class="Ltensorflow/data/Dataset" />
          <call class="Ltensorflow/data/Dataset" name="read_dataset" descriptor="()LRoot;" type="virtual" arg0="x" numArgs="1" def="xx" />
          <return value="xx" />
        </method>
      </class>
    </package>
    <package name="tensorflow/data/Dataset">
      <class name="from_tensors" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/data/Dataset#from_tensors -->
        <method name="do" descriptor="()LRoot;" numArgs="2" paramNames="tensors name">
          <!-- FIXME: We should encode the tensors argument here. See https://github.com/wala/ML/issues/164. -->
          <new def="x" class="Ltensorflow/data/Dataset" />
          <call class="Ltensorflow/data/Dataset" name="read_dataset" descriptor="()LRoot;" type="virtual" arg0="x" numArgs="1" def="xx" />
          <return value="xx" />
        </method>
      </class>
      <class name="from_tensor_slices" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/data/Dataset#from_tensor_slices -->
        <method name="do" descriptor="()LRoot;" numArgs="2" paramNames="tensors name">
          <new def="x" class="Ltensorflow/data/Dataset" />
          <call class="Ltensorflow/data/Dataset" name="read_dataset" descriptor="()LRoot;" type="virtual" arg0="x" numArgs="1" def="xx" />
          <putfield class="Ltensorflow/data/Dataset" field="tensors" fieldType="LRoot" ref="xx" value="tensors" />
          <return value="xx" />
        </method>
      </class>
      <class name="sample_from_datasets" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/data/Dataset#sample_from_datasets -->
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="datasets weights seed stop_on_empty_dataset">
          <new def="x" class="Ltensorflow/data/Dataset" />
          <call class="Ltensorflow/data/Dataset" name="read_dataset" descriptor="()LRoot;" type="virtual" arg0="x" numArgs="1" def="xx" />
          <return value="xx" />
        </method>
      </class>
      <class name="list_files" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/data/Dataset#list_files -->
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="file_pattern shuffle seed name">
          <new def="x" class="Ltensorflow/data/Dataset" />
          <call class="Ltensorflow/data/Dataset" name="read_dataset" descriptor="()LRoot;" type="virtual" arg0="x" numArgs="1" def="xx" />
          <return value="xx" />
        </method>
      </class>
      <class name="choose_from_datasets" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/data/Dataset#choose_from_datasets -->
        <method name="do" descriptor="()LRoot;" numArgs="3" paramNames="datasets choice_dataset stop_on_empty_dataset">
          <!-- Return the first one in the list. -->
          <constant name="l" type="int" value="0" />
          <aaload index="l" type="Ltensorflow/data/Dataset" ref="datasets" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="from_generator" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/data/Dataset#from_generator -->
        <method name="do" descriptor="()LRoot;" numArgs="6" paramNames="generator output_types output_shapes args output_signature name">
          <new def="x" class="Ltensorflow/data/Dataset" />
          <call class="Ltensorflow/data/Dataset" name="read_dataset" descriptor="()LRoot;" type="virtual" arg0="x" numArgs="1" def="xx" />
          <return value="xx" />
        </method>
      </class>
      <class name="zip" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/data/Dataset#zip -->
        <method name="do" descriptor="()LRoot;" numArgs="2" paramNames="datasets name">
          <new def="x" class="Ltensorflow/data/Dataset" />
          <call class="Ltensorflow/data/Dataset" name="read_dataset" descriptor="()LRoot;" type="virtual" arg0="x" numArgs="1" def="xx" />
          <!-- FIXME: This could return tuples of tensors. See https://github.com/wala/ML/issues/165. -->
          <return value="xx" />
        </method>
      </class>
      <class name="range" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/data/Dataset#range -->
        <method name="do" descriptor="()LRoot;" numArgs="2" paramNames="args kwargs">
          <new def="x" class="Ltensorflow/data/Dataset" />
          <call class="Ltensorflow/data/Dataset" name="read_dataset" descriptor="()LRoot;" type="virtual" arg0="x" numArgs="1" def="xx" />
          <return value="xx" />
        </method>
      </class>
      <class name="random" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/data/Dataset#random -->
        <method name="do" descriptor="()LRoot;" numArgs="2" paramNames="seed name">
          <new def="x" class="Ltensorflow/data/Dataset" />
          <call class="Ltensorflow/data/Dataset" name="read_dataset" descriptor="()LRoot;" type="virtual" arg0="x" numArgs="1" def="xx" />
          <return value="xx" />
        </method>
      </class>
    </package>
    <package name="tensorflow/estimator/train">
      <class name="train" allocatable="true">
        <method name="do" descriptor="()LRoot;" numArgs="6" paramNames="self input_fn hooks steps max_steps saving_listeners">
          <getfield class="LRoot" field="$callback" fieldType="LRoot" ref="self" def="xx" />
          <getfield class="LRoot" field="data" fieldType="LRoot" ref="input_fn" def="data" />
          <getfield class="LRoot" field="labels" fieldType="LRoot" ref="input_fn" def="labels" />
          <call class="LRoot" name="do" descriptor="()LRoot;" type="virtual" arg0="xx" arg1="data" arg2="labels" numArgs="3" def="v" />
          <return value="v" />
        </method>
      </class>
    </package>
    <package name="tensorflow/distribute">
      <class name="MirroredStrategy" allocatable="true">
        <method name="do" descriptor="()LRoot;" numArgs="3" paramNames="self devices cross_device_ops">
          <new def="x" class="Ltensorflow/distribute/run/run" />
          <putfield class="LRoot" field="run" fieldType="LRoot" ref="self" value="x" />
          <return value="arg0" />
        </method>
      </class>
    </package>
    <package name="tensorflow/distribute/run">
      <class name="run" allocatable="true">
        <method name="do" descriptor="()LRoot;" numArgs="3">
          <constant name="l" type="int" value="0" />
          <aaload index="l" type="LRoot" ref="arg2" def="x" />
          <call class="LRoot" name="do" descriptor="()LRoot;" type="virtual" arg0="arg1" arg1="x" numArgs="2" def="v" />
          <return value="v" />
        </method>
      </class>
    </package>
    <package name="tensorflow/app">
      <class name="run" allocatable="true">
        <method name="do" descriptor="()LRoot;" numArgs="3" paramNames="self main argv">
          <call class="LRoot" name="do" descriptor="()LRoot;" type="virtual" arg0="arg1" arg1="" def="v" />
          <return value="v" />
        </method>
      </class>
    </package>
    <package name="tensorflow/contrib/learn/datasets/base">
      <class name="Datasets" allocatable="true">
        <method name="next_batch" descriptor="()LRoot;" numArgs="2" paramNames="self batch_size">
          <new def="z" class="Ltensorflow/examples/tutorials/mnist/read_data_sets" />
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="z" numArgs="1" def="xs" />
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="z" numArgs="1" def="ys" />
          <new def="res" class="Llist" />
          <putfield class="LRoot" field="0" fieldType="LRoot" ref="res" value="xs" />
          <putfield class="LRoot" field="1" fieldType="LRoot" ref="res" value="ys" />
          <return value="res" />
        </method>
      </class>
    </package>
    <package name="tensorflow/examples/tutorials/mnist">
      <class name="read_data_sets" allocatable="true">
        <method name="read_data" descriptor="()LRoot;" numArgs="1">
          <new def="x" class="Ltensorflow/python/framework/ops/Tensor" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="9" paramNames="self train_dir fake_data one_hot dtype reshape validation_size seed source_url">
          <new def="test" class="Ltensorflow/contrib/learn/datasets/base/Datasets" />
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="x" />
          <putfield class="LRoot" field="images" fieldType="LRoot" ref="test" value="x" />
          <putfield class="LRoot" field="labels" fieldType="LRoot" ref="test" value="x" />
          <new def="training" class="Ltensorflow/contrib/learn/datasets/base/Datasets" />
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="y" />
          <putfield class="LRoot" field="images" fieldType="LRoot" ref="training" value="y" />
          <putfield class="LRoot" field="labels" fieldType="LRoot" ref="training" value="y" />
          <new def="validation" class="Ltensorflow/contrib/learn/datasets/base/Datasets" />
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" numArgs="1" def="z" />
          <putfield class="LRoot" field="images" fieldType="LRoot" ref="validation" value="z" />
          <putfield class="LRoot" field="labels" fieldType="LRoot" ref="validation" value="z" />
          <new def="data" class="Lobject" />
          <putfield class="LRoot" field="test" fieldType="LRoot" ref="data" value="test" />
          <putfield class="LRoot" field="train" fieldType="LRoot" ref="data" value="training" />
          <putfield class="LRoot" field="validation" fieldType="LRoot" ref="data" value="validation" />
          <return value="data" />
        </method>
      </class>
      <class name="input_data" allocatable="true">
      </class>
      <class name="dataset" allocatable="true">
      </class>
    </package>
    <package name="tensorflow/examples/tutorials">
      <class name="mnist" allocatable="true">
        <method name="import" static="true" descriptor="()Ltensorflow/examples/tutorials/mnist;">
          <new def="x" class="Ltensorflow/examples/tutorials/mnist" />
          <call name="__init__" class="Ltensorflow/examples/tutorials/mnist" descriptor="()V" type="virtual" arg0="x" numArgs="1" />
          <return value="x" />
        </method>
        <method name="__init__" descriptor="()V">
          <new def="x" class="Ltensorflow/examples/tutorials/mnist/input_data" />
          <new def="y" class="Ltensorflow/examples/tutorials/mnist/read_data_sets" />
          <putfield class="Ltensorflow/examples/tutorials/mnist" field="input_data" fieldType="LRoot" ref="arg0" value="x" />
          <putfield class="Ltensorflow/examples/tutorials/mnist/input_data" field="read_data_sets" fieldType="LRoot" ref="x" value="y" />
        </method>
      </class>
    </package>
    <package name="tensorflow/python/framework/constant_op">
      <class name="constant" allocatable="true" />
    </package>
    <package name="tensorflow/python/ops/linalg_ops">
      <class name="eye" allocatable="true" />
    </package>
  </classloader>
</summary-spec>
